{"version":3,"file":"static/chunks/pages/_error-57c7d86035a5a05a.js","mappings":"qaACA,CAAAA,OAAAC,QAAA,CAAAD,OAAAC,QAAA,MAAAC,IAAA,EACA,UACA,WACA,OAAeC,EAAQ,MACvB,EACA,8ICuCA,eAAAC,IACA,IACIC,EAAAC,CAAW,EAAIC,EAAAC,EAAM,CAAAC,GAAA,uBACzB,MAAU,GAAAC,EAAAC,EAAA,EAAK,KACXN,EAAAC,CAAW,EAAIC,EAAAC,EAAM,CAAAC,GAAA,wBACzB,CAAI,MAAAG,EAAA,CACAP,EAAAC,CAAW,EAAIC,EAAAC,EAAM,CAAAC,GAAA,kCAAAG,EACzB,CACA,sCE5CA,eAAAC,EAAAC,CAAA,EACA,IAAUC,IAAAA,CAAA,CAAAC,IAAAA,CAAA,CAAAC,IAAAA,CAAA,EAAgBH,EAG1BI,EAAA,GAAAF,EAAAE,UAAA,EAAAJ,EAAAI,UAAA,CACA,GAAAA,GAAAA,EAAA,KAWA,CAAAJ,EAAAK,QAAA,CAVA,OAAAC,QAAAC,OAAA,GAcE,GAAAC,EAAAC,EAAA,EAASC,IACXT,GACAS,EAAAC,wBAAA,EAAuCC,QAAAX,CAAA,GAKnC,GAAAL,EAAAiB,EAAA,EAAgBV,GAAA,sCAA8CA,EAAI,IACtEW,UAAA,CACAC,KAAA,aACAC,QAAA,GACAC,KAAA,CACAC,SAAA,wBACA,CACA,CACA,EACA,GAEEC,SDvCFC,CAAA,EACA,IAAAC,EAEIC,EAAAC,UAAU,CAAAC,OAAAC,GAAA,6BAEdC,EAAc,GAAAC,EAAAC,CAAA,EAAiB,GAAAC,EAAAC,CAAA,EAAc,CAAAT,EAAA,iBAAAU,GAAAA,EAAAC,GAAA,gBAAAC,GAAAA,IAAA,YAC3C,GAAAJ,EAAAC,CAAA,EAAc,CAAAJ,EAAA,SAAAQ,GAAAA,EAAAC,SAAA,gBAAAC,GAAAA,EAAAhB,GAAA,CAChB,ECgCkB9B,IAClB,yBC7CA,IAAM+C,EAAuB,GACpB,GAAAC,EAAAC,GAAA,EAACC,IAAKA,CAACpC,WAAYqC,EAAMrC,UAAU,EAG5CiC,CAAAA,EAAqBK,eAAe,CAAG,MAAOC,IAG5C,MAAMC,EAAuCD,GAGtCH,IAAAA,eAAqB,CAACG,IAG/B,IAAAE,EAAeR,yBChBfS,EAAAC,OAAA,CAAA1D,EAAA","sources":["webpack://_N_E/?fa0a","webpack://_N_E/./node_modules/@sentry/nextjs/build/esm/common/utils/responseEnd.js","webpack://_N_E/./node_modules/@sentry/nextjs/build/esm/common/utils/vercelWaitUntil.js","webpack://_N_E/./node_modules/@sentry/nextjs/build/esm/common/_error.js","webpack://_N_E/./pages/_error.jsx","webpack://_N_E/./node_modules/next/error.js"],"sourcesContent":["\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_error\",\n      function () {\n        return require(\"private-next-pages/_error.jsx\");\n      }\n    ]);\n    if(module.hot) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_error\"])\n      });\n    }\n  ","import { flush, setHttpStatus } from '@sentry/core';\nimport { logger, fill } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\n\n/**\n * Wrap `res.end()` so that it ends the span and flushes events before letting the request finish.\n *\n * Note: This wraps a sync method with an async method. While in general that's not a great idea in terms of keeping\n * things in the right order, in this case it's safe, because the native `.end()` actually *is* (effectively) async, and\n * its run actually *is* (literally) awaited, just manually so (which reflects the fact that the core of the\n * request/response code in Node by far predates the introduction of `async`/`await`). When `.end()` is done, it emits\n * the `prefinish` event, and only once that fires does request processing continue. See\n * https://github.com/nodejs/node/commit/7c9b607048f13741173d397795bac37707405ba7.\n *\n * Also note: `res.end()` isn't called until *after* all response data and headers have been sent, so blocking inside of\n * `end` doesn't delay data getting to the end user. See\n * https://nodejs.org/api/http.html#responseenddata-encoding-callback.\n *\n * @param span The span tracking the request\n * @param res: The request's corresponding response\n */\nfunction autoEndSpanOnResponseEnd(span, res) {\n  const wrapEndMethod = (origEnd) => {\n    return function sentryWrappedEnd( ...args) {\n      finishSpan(span, this);\n      return origEnd.call(this, ...args);\n    };\n  };\n\n  // Prevent double-wrapping\n  // res.end may be undefined during build when using `next export` to statically export a Next.js app\n  if (res.end && !(res.end ).__sentry_original__) {\n    fill(res, 'end', wrapEndMethod);\n  }\n}\n\n/** Finish the given response's span and set HTTP status data */\nfunction finishSpan(span, res) {\n  setHttpStatus(span, res.statusCode);\n  span.end();\n}\n\n/**\n * Flushes pending Sentry events with a 2 second timeout and in a way that cannot create unhandled promise rejections.\n */\nasync function flushSafelyWithTimeout() {\n  try {\n    DEBUG_BUILD && logger.log('Flushing events...');\n    await flush(2000);\n    DEBUG_BUILD && logger.log('Done flushing events');\n  } catch (e) {\n    DEBUG_BUILD && logger.log('Error while flushing events:\\n', e);\n  }\n}\n\nexport { autoEndSpanOnResponseEnd, finishSpan, flushSafelyWithTimeout };\n//# sourceMappingURL=responseEnd.js.map\n","import { _nullishCoalesce, _optionalChain } from '@sentry/utils';\nimport { GLOBAL_OBJ } from '@sentry/utils';\n\n/**\n * Function that delays closing of a Vercel lambda until the provided promise is resolved.\n *\n * Vendored from https://www.npmjs.com/package/@vercel/functions\n */\nfunction vercelWaitUntil(task) {\n  const vercelRequestContextGlobal =\n    // @ts-expect-error This is not typed\n    GLOBAL_OBJ[Symbol.for('@vercel/request-context')];\n\n  const ctx = _nullishCoalesce(_optionalChain([vercelRequestContextGlobal, 'optionalAccess', _ => _.get, 'optionalCall', _2 => _2()]), () => ( {}));\n  _optionalChain([ctx, 'access', _3 => _3.waitUntil, 'optionalCall', _4 => _4(task)]);\n}\n\nexport { vercelWaitUntil };\n//# sourceMappingURL=vercelWaitUntil.js.map\n","import { withScope, captureException } from '@sentry/core';\nimport { flushSafelyWithTimeout } from './utils/responseEnd.js';\nimport { vercelWaitUntil } from './utils/vercelWaitUntil.js';\n\n/**\n * Capture the exception passed by nextjs to the `_error` page, adding context data as appropriate.\n *\n * @param contextOrProps The data passed to either `getInitialProps` or `render` by nextjs\n */\nasync function captureUnderscoreErrorException(contextOrProps) {\n  const { req, res, err } = contextOrProps;\n\n  // 404s (and other 400-y friends) can trigger `_error`, but we don't want to send them to Sentry\n  const statusCode = (res && res.statusCode) || contextOrProps.statusCode;\n  if (statusCode && statusCode < 500) {\n    return Promise.resolve();\n  }\n\n  // In previous versions of the suggested `_error.js` page in which this function is meant to be used, there was a\n  // workaround for https://github.com/vercel/next.js/issues/8592 which involved an extra call to this function, in the\n  // custom error component's `render` method, just in case it hadn't been called by `getInitialProps`. Now that that\n  // issue has been fixed, the second call is unnecessary, but since it lives in user code rather than our code, users\n  // have to be the ones to get rid of it, and guaraneteedly, not all of them will. So, rather than capture the error\n  // twice, we just bail if we sense we're in that now-extraneous second call. (We can tell which function we're in\n  // because Nextjs passes `pathname` to `getInitialProps` but not to `render`.)\n  if (!contextOrProps.pathname) {\n    return Promise.resolve();\n  }\n\n  withScope(scope => {\n    if (req) {\n      scope.setSDKProcessingMetadata({ request: req });\n    }\n\n    // If third-party libraries (or users themselves) throw something falsy, we want to capture it as a message (which\n    // is what passing a string to `captureException` will wind up doing)\n    captureException(err || `_error.js called with falsy error (${err})`, {\n      mechanism: {\n        type: 'instrument',\n        handled: false,\n        data: {\n          function: '_error.getInitialProps',\n        },\n      },\n    });\n  });\n\n  vercelWaitUntil(flushSafelyWithTimeout());\n}\n\nexport { captureUnderscoreErrorException };\n//# sourceMappingURL=_error.js.map\n","import * as Sentry from \"@sentry/nextjs\";\nimport Error from \"next/error\";\n\nconst CustomErrorComponent = (props) => {\n  return <Error statusCode={props.statusCode} />;\n};\n\nCustomErrorComponent.getInitialProps = async (contextData) => {\n  // In case this is running in a serverless function, await this in order to give Sentry\n  // time to send the error before the lambda exits\n  await Sentry.captureUnderscoreErrorException(contextData);\n\n  // This will contain the status code of the response\n  return Error.getInitialProps(contextData);\n};\n\nexport default CustomErrorComponent;\n","module.exports = require('./dist/pages/_error')\n"],"names":["window","__NEXT_P","push","__webpack_require__","flushSafelyWithTimeout","debug_build","X","logger","kg","log","esm_exports","yl","e","captureUnderscoreErrorException","contextOrProps","req","res","err","statusCode","pathname","Promise","resolve","currentScopes","$e","scope","setSDKProcessingMetadata","request","Tb","mechanism","type","handled","data","function","vercelWaitUntil","task","vercelRequestContextGlobal","worldwide","GLOBAL_OBJ","Symbol","for","ctx","_nullishCoalesce","h","_optionalChain","x","_","get","_2","_3","waitUntil","_4","CustomErrorComponent","jsx_runtime","jsx","Error","props","getInitialProps","contextData","Sentry","_error","module","exports"],"sourceRoot":""}